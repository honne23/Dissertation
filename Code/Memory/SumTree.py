import numpy as npclass SumTree:    """    Source: https://github.com/jaromiru/AI-blog/blob/master/SumTree.py    """    write: int = 0    full : bool = False        def __init__(self, capacity):        self.capacity = capacity        self.tree = np.zeros( 2*capacity - 1 )        self.data = np.zeros( capacity, dtype=object )        self.size = 0    def _propagate(self, idx, change):        parent = (idx - 1) // 2        self.tree[parent] += change        if parent != 0:            self._propagate(parent, change)    def _retrieve(self, idx, s):        left = 2 * idx + 1        right = left + 1        if left >= len(self.tree):            return idx        if s <= self.tree[left]:            return self._retrieve(left, s)        else:            return self._retrieve(right, s-self.tree[left])    def total(self):        return self.tree[0]    def add(self, p, data):        idx = self.write + self.capacity - 1        self.data[self.write] = data        self.update(idx, p)        self.write += 1        self.size = min(self.size + 1, self.capacity)        if self.write >= self.capacity:            self.full = True            self.write = 0    def update(self, idx, p):        change = p - self.tree[idx]        self.tree[idx] = p        self._propagate(idx, change)    def get(self, s):        idx = self._retrieve(0, s)        dataIdx = idx - self.capacity + 1        return [idx, self.tree[idx], self.data[dataIdx]]        def __len__(self):        return self.size        def getMid(self,s, e):         return s + (e - s) // 2  # /* A recursive function to get the sum of     # values in given range of the array.     # The following are parameters for this     # function.     #     # st     -> Pointer to segment tree     # node     -> Index of current node in     #             the segment tree .     # ss & se -> Starting and ending indexes     #             of the segment represented     #             by current node, i.e., st[node]     # l & r -> Starting and ending indexes     #             of range query */     def MaxUtil(self, ss, se, l,r, node):                   # If segment of this node is completely         # part of given range, then return         # the max of segment         if (l <= ss and r >= se):             return self.tree[node]               # If segment of this node does not         # belong to given range         if (se < l or ss > r):             return -1              # If segment of this node is partially         # the part of given range         mid = self.getMid(ss, se)               return max(self.MaxUtil(ss, mid, l, r, \                        2 * node + 1), \                self.MaxUtil(mid + 1, se, l, r, 2 * node + 2))                 def getMax(self):               return self.MaxUtil(0, self.size - 1, 0, self.size, 0)                 